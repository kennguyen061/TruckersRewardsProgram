'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = jssExpand;

var _props = require('./props');

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Map values by given prop.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {String} original rule
 * @return {String} mapped values
 */
function mapValuesByProp(value, prop, rule) {
  return value.map(function (item) {
    return objectToString(item, prop, rule);
  });
}

/**
 * Convert array to string.
 *
 * @param {Array} array of values
 * @param {String} original property
 * @param {Object} sheme, for converting arrays in strings
 * @param {Object} original rule
 * @return {String} converted string
 */
function arrayToString(value, prop, scheme, rule) {
  if (value[0].constructor === Object) return mapValuesByProp(value, prop, rule);
  if (scheme[prop] == null) return value.join(',');
  if (value[0].constructor === Array) return arrayToString(value[0], prop, scheme);
  return value.join(' ');
}

/**
 * Convert object to string.
 *
 * @param {Object} object of values
 * @param {String} original property
 * @param {Object} original rule
 * @return {String} converted string
 */
function objectToString(value, prop, rule) {
  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return '';

  var result = [];

  // Check if exists any non-standart property
  if (_props.customPropObj[prop]) {
    for (var baseProp in _props.customPropObj[prop]) {
      var propName = _props.customPropObj[prop][baseProp];
      // If current property doesn't exist alerady in rule - add new one
      if (value[baseProp] && !rule.prop(propName)) {
        rule.prop(propName, styleDetector(_defineProperty({}, propName, value[baseProp]), rule)[propName]);
      }
      delete value[baseProp];
    }
  }

  // Pass throught all standart props
  if (Object.keys(value).length !== 0) {
    for (var _baseProp in _props.propObj[prop]) {
      if (value[_baseProp]) {
        if (value[_baseProp].constructor === Array) {
          result.push(arrayToString(value[_baseProp], _baseProp, _props.propArrayInObj));
        } else result.push(value[_baseProp]);
        continue;
      }

      // Add default value from props config.
      if (_props.propObj[prop][_baseProp] != null) {
        result.push(_props.propObj[prop][_baseProp]);
      }
    }
  }

  return result.join(' ');
}

/**
 * Detect if a style needs to be converted.
 *
 * @param {Object} style
 * @param {Object} rule
 * @return {Object} convertedStyle
 */
function styleDetector(style, rule) {
  for (var prop in style) {
    var value = style[prop];

    if (value.constructor === Object) {
      if (prop === 'fallbacks') style[prop] = styleDetector(style[prop]);else {
        style[prop] = objectToString(value, prop, rule);
        // Avoid creating properties with empty values
        if (!style[prop]) delete style[prop];
      }
      continue;
    }

    // Check double arrays to avoid recursion.
    if (value.constructor === Array && value[0].constructor !== Array) {
      if (prop === 'fallbacks') {
        for (var index = 0; index < style[prop].length; index++) {
          style[prop][index] = styleDetector(style[prop][index]);
        }
        continue;
      }

      style[prop] = arrayToString(value, prop, _props.propArray);
    }
  }
  return style;
}

/**
 * Adds possibility to write expanded styles.
 *
 * @param {Rule} rule
 * @api public
 */
function jssExpand() {
  return function (rule) {
    var style = rule.style;
    var type = rule.type;

    if (!style || type !== 'regular') return;

    if (Array.isArray(style)) {
      // Pass rules one by one and reformat them
      for (var index = 0; index < style.length; index++) {
        style[index] = styleDetector(style[index], rule);
      }
      return;
    }

    rule.style = styleDetector(style, rule);
  };
}